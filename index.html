

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SNAKE</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background-color: #222;
    font-family: Arial, sans-serif;
    height: 100vh;
    overflow: hidden;
  }
  canvas {
    background-color: #000;
    border: 2px solid #fff;
    display: block;
    margin: auto;
    transition: opacity 0.3s ease;
  }
  #message {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 1.2em;
    color: #ff0;
    z-index: 10;
  }
  #ticker {
    position: absolute;
    top: 50%;
    left: -100%;
    transform: translateY(-50%);
    white-space: nowrap;
    font-size: 60px;
    color: #fff;
    font-weight: bold;
    z-index: 20;
    animation: none;
  }
  @keyframes slideTicker {
    0% { left: -100%; }
    100% { left: 100%; }
  }
  #pauseBtn {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
    padding: 8px 12px;
    font-size: 1em;
    background-color: #444;
    color: #fff;
    border: none;
    cursor: pointer;
  }
  #mathMode {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #222;
    color: #fff;
    z-index: 30;
  }
  #mathQuestion {
    font-size: 48px;
    margin-bottom: 20px;
  }
  #mathAnswer {
    font-size: 32px;
    padding: 10px;
    width: 200px;
    text-align: center;
  }
  #submitAnswer {
    margin-top: 10px;
    font-size: 24px;
    padding: 8px 16px;
    cursor: pointer;
  }
</style>
</head>
<body>
<div id="message"></div>
<div id="ticker"></div>
<button id="pauseBtn">Pause</button>
<canvas id="gameCanvas" width="1350" height="595"></canvas>
<div id="mathMode">
  <div id="mathQuestion"></div>
  <input type="text" id="mathAnswer" placeholder="Your answer" />
  <button id="submitAnswer">Submit</button>
</div>




<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const message = document.getElementById("message");
  const ticker = document.getElementById("ticker");
  const pauseBtn = document.getElementById("pauseBtn");
  const mathMode = document.getElementById("mathMode");
  const mathQuestion = document.getElementById("mathQuestion");
  const mathAnswer = document.getElementById("mathAnswer");
  const submitAnswer = document.getElementById("submitAnswer");




  const gridSize = 20;
  const tileCountX = canvas.width / gridSize;
  const tileCountY = canvas.height / gridSize;




  let snake = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
  let direction = { x: 1, y: 0 }; // Start moving right
  let lastDirection = { x: 1, y: 0 }; // Remember last valid direction to prevent backward move
  let foods = [randomTile()];
  let score = 9999999999;
  let highScore = localStorage.getItem("snakeHighScore") || 0;




  let monsters = [];
  let monsterMoveCounter = 0;
  let baseInterval = 100;
  let speed = baseInterval;




  let shieldActive = false;




  let powerUp = null;
  let powerUpType = null;




  let comboCount = 0;
  let comboActivated = {};
  let comboDoublePointsLeft = 0;




  let lastTime = 0;
  let pressedKeys = {};
  let paused = false;
  let inMathMode = false;
  let gameStarted = false;




  function randomTile() {
    return {
      x: Math.floor(Math.random() * tileCountX),
      y: Math.floor(Math.random() * tileCountY)
    };
  }




  function showStartScreen() {
    message.textContent = "Press SPACE to start - M for Math Mode - P to Pause - Avoid Blue Monsters!";
    canvas.style.opacity = 0.3;
  }




  function showTicker(text) {
    ticker.textContent = text;
    ticker.style.animation = "none";
    void ticker.offsetWidth;
    ticker.style.animation = "slideTicker 4s linear forwards";
  }




  function generateMathProblem() {
    const types = ["linear", "exponent", "sqrt", "fraction", "order"];
    const type = types[Math.floor(Math.random() * types.length)];
    let question = "", answer = "";




    if (type === "linear") {
      const a = Math.floor(Math.random() * 10) + 1;
      const x = Math.floor(Math.random() * 10);
      const b = Math.floor(Math.random() * 10);
      const result = a * x + b;
      question = `Solve for x: ${a}x + ${b} = ${result}`;
      answer = x.toString();
    } else if (type === "exponent") {
      const base = Math.floor(Math.random() * 9) + 2;
      const exp = Math.floor(Math.random() * 3) + 2;
      question = `${base}^${exp}`;
      answer = Math.pow(base, exp).toString();
    } else if (type === "sqrt") {
      const root = Math.floor(Math.random() * 15) + 1;
      const square = root * root;
      question = `âˆš${square}`;
      answer = root.toString();
    } else if (type === "fraction") {
      const a = Math.floor(Math.random() * 9) + 1;
      const b = Math.floor(Math.random() * 9) + 1;
      const c = Math.floor(Math.random() * 9) + 1;
      const d = Math.floor(Math.random() * 9) + 1;
      const op = Math.random() < 0.5 ? "+" : "-";
      question = `${a}/${b} ${op} ${c}/${d}`;
      const val = op === "+" ? (a / b + c / d) : (a / b - c / d);
      answer = val.toFixed(2);
    } else if (type === "order") {
      const a = Math.floor(Math.random() * 10);
      const b = Math.floor(Math.random() * 10);
      const c = Math.floor(Math.random() * 10);
      question = `${a} + ${b} Ã— (${c} - 1)`;
      answer = (a + b * (c - 1)).toString();
    }




    mathQuestion.textContent = question;
    mathAnswer.value = "";
    mathAnswer.dataset.correct = answer;
  }




  submitAnswer.onclick = () => {
    const userAnswer = mathAnswer.value.trim();
    const correct = mathAnswer.dataset.correct;
    const isCorrect = parseFloat(userAnswer).toFixed(2) === parseFloat(correct).toFixed(2);




    if (isCorrect) {
      comboCount++;
      alert(`âœ… Correct! Combo x${comboCount}`);
      showTicker(`Combo x${comboCount}!`);




      if (comboCount >= 3 && !comboActivated[3]) {
        comboDoublePointsLeft = 2;
        comboActivated[3] = true;
      }
      if (comboCount >= 5 && !comboActivated[5]) {
        powerUp = randomTile();
        powerUpType = "shield";  // Magnet removed
        comboActivated[5] = true;
      }
      if (comboCount >= 15 && !comboActivated[15]) {
        monsters.splice(0, 10);
        showTicker("ðŸ’¥ Combo x15! 10 monsters deleted!");
        comboActivated[15] = true;
      }
      if (comboCount >= 20 && !comboActivated[20]) {
        for (let i = 0; i < 20; i++) {
          foods.push(randomTile());
        }
        showTicker("ðŸŽ Combo x20! 20 apples spawned!");
        comboActivated[20] = true;
      }
      if (comboCount >= 100 && !comboActivated[100]) {
        score += 50;
        showTicker("ðŸŽ‰ Combo x100! +50 points!");
        comboActivated[100] = true;
      }
    } else {
      alert(`âŒ Incorrect. Correct answer was ${correct}`);
      comboCount = 0;
      comboActivated = {};
      comboDoublePointsLeft = 0;
    }




    generateMathProblem();
  };




  pauseBtn.onclick = () => {
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume" : "Pause";
  };




  document.addEventListener("keydown", (e) => {
    pressedKeys[e.key] = true;
    if (e.key === " ") {
      if (!gameStarted) startGame();
    }
    if (e.key.toLowerCase() === "m") {
      if (!inMathMode) {
        mathMode.style.display = "flex";
        canvas.style.display = "none";
        pauseBtn.style.display = "none";
        message.style.display = "none";
        generateMathProblem(5);
        inMathMode = true;
        paused = true;
      } else {
        mathMode.style.display = "none";
        canvas.style.display = "block";
        pauseBtn.style.display = "block";
        message.style.display = "block";
        inMathMode = false;
        paused = false;
      }
    }
    if (e.key.toLowerCase() === "p") {
      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
    }
  });




  document.addEventListener("keyup", (e) => {
    delete pressedKeys[e.key];
  });




  function updateDirection() {
    // Prevent snake from turning back into itself by disallowing 180 deg reversals
    if (pressedKeys["ArrowUp"] || pressedKeys["w"]) {
      if (lastDirection.y !== 1) direction = { x: 0, y: -1 };
    } else if (pressedKeys["ArrowDown"] || pressedKeys["s"]) {
      if (lastDirection.y !== -1) direction = { x: 0, y: 1 };
    } else if (pressedKeys["ArrowLeft"] || pressedKeys["a"]) {
      if (lastDirection.x !== 1) direction = { x: -1, y: 0 };
    } else if (pressedKeys["ArrowRight"] || pressedKeys["d"]) {
      if (lastDirection.x !== -1) direction = { x: 1, y: 0 };
    }
  }




  function drawTile(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * gridSize, y * gridSize, gridSize - 2, gridSize - 2);
  }




  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    snake.forEach((segment, i) => drawTile(segment.x, segment.y, i === 0 ? "#0f0" : "#0a0"));
    foods.forEach(food => drawTile(food.x, food.y, "#f00"));
    monsters.forEach(monster => drawTile(monster.x, monster.y, "#00f"));
    if (powerUp) drawTile(powerUp.x, powerUp.y, "#ff0");
  }




  function moveMonsters() {
    monsterMoveCounter++;
    if (monsterMoveCounter % 10 !== 0) return;
    monsters.forEach(monster => {
      const head = snake[0];
      const dx = head.x - monster.x;
      const dy = head.y - monster.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        monster.x += dx > 0 ? 1 : -1;
      } else if (Math.abs(dy) > 0) {
        monster.y += dy > 0 ? 1 : -1;
      }
    });
  }




  function update() {
    if (!gameStarted || paused || inMathMode) return;
    updateDirection();




    // Only update lastDirection if the new direction is not directly opposite
    if ((direction.x !== -lastDirection.x) || (direction.y !== -lastDirection.y)) {
      lastDirection = direction;
    }




    moveMonsters();




    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
    if (
      head.x < 0 || head.x >= tileCountX ||
      head.y < 0 || head.y >= tileCountY ||
      snake.some(seg => seg.x === head.x && seg.y === head.y)
    ) {
      alert("You Died! Get Better Lazy Bum.");
      setTimeout(() => location.reload(), 100);
      return;
    }




    snake.unshift(head);




    let ateFood = false;
    foods = foods.filter(food => {
      if (head.x === food.x && head.y === food.y) {
        ateFood = true;
        return false;
      }
      return true;
    });




    if (ateFood) {
      let points = 1;
      if (comboDoublePointsLeft > 0) {
        points = 2;
        comboDoublePointsLeft--;
      }
      score += points;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem("snakeHighScore", highScore);
      }




      monsters.push(randomTile());




      const newFoodCount = Math.floor(score / 3) + 1;
      while (foods.length < newFoodCount) {
        foods.push(randomTile());
      }




      if (score % 7 === 0) {
        powerUp = randomTile();
        powerUpType = "shield";
        showTicker(`Power-Up: ${powerUpType.toUpperCase()}!`);
      }
    } else {
      snake.pop();
    }




    for (let i = 0; i < monsters.length; i++) {
      if (head.x === monsters[i].x && head.y === monsters[i].y) {
        if (shieldActive) {
          monsters.splice(i, 1);
          shieldActive = false;
        } else {
          alert("Caught by a monster!");
          location.reload();
          return;
        }
        break;
      }
    }




    if (powerUp && head.x === powerUp.x && head.y === powerUp.y) {
      if (powerUpType === "shield") {
        shieldActive = true;
      }
      powerUp = null;
      powerUpType = null;
    }




    message.textContent = `Score: ${score} | High Score: ${highScore}` +
      (shieldActive ? " | Shield ON" : "") +
      (comboCount > 0 ? ` | Combo x${comboCount}` : "");




    draw();
  }




  function gameLoop(timestamp) {
    if (timestamp - lastTime > speed) {
      update();
      lastTime = timestamp;
    }
    requestAnimationFrame(gameLoop);
  }




  function startGame() {
    gameStarted = true;
    canvas.style.opacity = 1;
    direction = { x: 1, y: 0 };
    lastDirection = { x: 1, y: 0 };
    score = 0;
    comboCount = 0;
    comboActivated = {};
    comboDoublePointsLeft = 0;
    shieldActive = false;
    snake = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
    foods = [randomTile()];
    monsters = [];
    powerUp = null;
    powerUpType = null;
    message.textContent = `Score: ${score} | High Score: ${highScore}`;
  }




  showStartScreen();
  requestAnimationFrame(gameLoop);

</script>
</body>
</html>

